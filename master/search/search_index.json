{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Maesh: Simpler Service Mesh \u00b6 Maesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Maesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh. Non-Invasive Service Mesh \u00b6 Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your Kubernetes objects and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required. Prerequisites \u00b6 To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Welcome"},{"location":"#maesh-simpler-service-mesh","text":"Maesh is a lightweight and simpler service mesh designed from the ground up to be straightforward, easy to install and easy to use. Built on top of Traefik, Maesh fits as your de-facto service mesh in your Kubernetes cluster supporting the latest Service Mesh Interface specification (SMI). Moreover, Maesh is opt-in by default, which means that your existing services are unaffected until you decide to add them to the mesh.","title":"Maesh: Simpler Service Mesh"},{"location":"#non-invasive-service-mesh","text":"Maesh does not use any sidecar container but handles routing through proxy endpoints running on each node. The mesh controller runs in a dedicated pod and handles all the configuration parsing and deployment to the proxy nodes. Maesh supports multiple configuration options: annotations on user service objects, and SMI objects. Not using sidecars means that Maesh does not modify your Kubernetes objects and does not modify your traffic without your knowledge. Using the Maesh endpoints is all that is required.","title":"Non-Invasive Service Mesh"},{"location":"#prerequisites","text":"To run this app, you require the following: Kubernetes 1.11+ CoreDNS/KubeDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Prerequisites"},{"location":"api/","text":"API \u00b6 Maesh includes a built-in API that can be used for debugging purposes. This can be useful when Maesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths: /api/configuration/current \u00b6 This endpoint provides raw json of the current configuration built by the controller. Note This may change on each request, as it is a live data structure. /api/status/nodes \u00b6 This endpoint provides a json array containing some details about the readiness of the Maesh nodes visible by the controller This endpoint will still return a 200 if there are no visible nodes. /api/status/node/{maesh-pod-name}/configuration \u00b6 This endpoint provides raw json of the current configuration on the Maesh node with the pod name given in {maesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller. /api/status/readiness \u00b6 This endpoint returns a 200 response if the controller successfully deployed a configuration to all Maesh nodes, and Maesh is ready for use. Otherwise, it will return a 500.","title":"API"},{"location":"api/#api","text":"Maesh includes a built-in API that can be used for debugging purposes. This can be useful when Maesh is not working as intended. The API is accessed via the controller pod, and for security reasons is not exposed via service. The API can be accessed by making a GET request to http://<control pod IP>:9000 combined with one of the following paths:","title":"API"},{"location":"api/#apiconfigurationcurrent","text":"This endpoint provides raw json of the current configuration built by the controller. Note This may change on each request, as it is a live data structure.","title":"/api/configuration/current"},{"location":"api/#apistatusnodes","text":"This endpoint provides a json array containing some details about the readiness of the Maesh nodes visible by the controller This endpoint will still return a 200 if there are no visible nodes.","title":"/api/status/nodes"},{"location":"api/#apistatusnodemaesh-pod-nameconfiguration","text":"This endpoint provides raw json of the current configuration on the Maesh node with the pod name given in {maesh-pod-name} . This endpoint provides a 404 response if the pod cannot be found, or other non-200 status codes on other errors. If errors are encountered, the error will be returned in the body, and logged on the controller.","title":"/api/status/node/{maesh-pod-name}/configuration"},{"location":"api/#apistatusreadiness","text":"This endpoint returns a 200 response if the controller successfully deployed a configuration to all Maesh nodes, and Maesh is ready for use. Otherwise, it will return a 500.","title":"/api/status/readiness"},{"location":"compatibility/","text":"Compatibility \u00b6 Maesh supports similiar to Kubernetes at least the latest 3 minor versions of Kubernetes, therefore currently: 1.16 1.17 1.18 General functionality can not be guaranted for versions older than that. However, we expect it to work with Kubernetes down to 1.11 currently. Compatibility by Features \u00b6 Some of Maesh's features are only supported on certain Kubernetes versions. Please see the table below. Features K8s 1.16 K8s 1.17 K8s 1.18 General functionality \u2714 \u2714 \u2714 Service Topology \u2718 \u2714 \u2714","title":"Compatibility"},{"location":"compatibility/#compatibility","text":"Maesh supports similiar to Kubernetes at least the latest 3 minor versions of Kubernetes, therefore currently: 1.16 1.17 1.18 General functionality can not be guaranted for versions older than that. However, we expect it to work with Kubernetes down to 1.11 currently.","title":"Compatibility"},{"location":"compatibility/#compatibility-by-features","text":"Some of Maesh's features are only supported on certain Kubernetes versions. Please see the table below. Features K8s 1.16 K8s 1.17 K8s 1.18 General functionality \u2714 \u2714 \u2714 Service Topology \u2718 \u2714 \u2714","title":"Compatibility by Features"},{"location":"configuration/","text":"Configuration \u00b6 The configuration for Maesh is broken down into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the service mesh is installed and is configured via the values.yaml file in the Helm install. Static configuration \u00b6 The Maesh image version can be manually defined if needed. Logging level and format for controller and proxies can be defined. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Access-Control List (ACL) mode can be enabled. This configures Maesh to run in ACL mode, where all traffic is forbidden unless explicitly allowed via an SMI TrafficTarget . Please see the SMI Specification for more information. Dynamic configuration \u00b6 Dynamic configuration can be provided to Maesh using annotations on Kubernetes services and via SMI objects. Features ACL disabled ACL enabled Traffic-Type \u2714 \u2714 Scheme \u2714 \u2714 Retry \u2714 \u2714 Circuit-Breaker \u2714 \u2714 Rate-Limit \u2714 \u2714 Traffic-Split (SMI) \u2714 \u2714 Traffic-Target (SMI) \u2718 \u2714 Kubernetes Service Annotations \u00b6 Annotations on services give the ability to configure how Maesh interprets them. Traffic type \u00b6 The traffic type can be configured by using the following annotation: maesh.containo.us/traffic-type: \"http\" This annotation can be set to either http , tcp or udp and will specifies the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration. Info For now, the udp traffic type does not work when ACL mode is enabled. In ACL mode, all traffic is forbidden unless it is explicitly allowed with a TrafficTarget and unfortunately the SMI specification does not yet define a Traffic Spec for UDP . Scheme \u00b6 The scheme used to define custom scheme for request: maesh.containo.us/scheme: \"h2c\" This annotation can be set to either http , https or h2c and is available for maesh.containo.us/traffic-type: \"http\" . Limitations Please keep in mind, that if you set the scheme to https your service needs to expose itself via HTTPS as there is no mTLS in Maesh. Retry \u00b6 Retries can be enabled by using the following annotation: maesh.containo.us/retry-attempts: \"2\" This annotation sets the number of retry attempts that Maesh will make if a network error occurs. Please note that this value is a string, and needs to be quoted. Circuit breaker \u00b6 Circuit breaker can be enabled by using the following annotation: maesh.containo.us/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here . Rate Limit \u00b6 Rate limiting can be enabled by using the following annotations: maesh.containo.us/ratelimit-average: \"100\" maesh.containo.us/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here . Service Mesh Interface \u00b6 Access Control \u00b6 The first step is to describe what the traffic of our server application looks like. --- apiVersion: specs.smi-spec.io/v1alpha1 kind: HTTPRouteGroup metadata: name: server-routes namespace: server matches: - name: api pathRegex: /api methods: [\"*\"] - name: metrics pathRegex: /metrics methods: [\"GET\"] In this example, we define a set of HTTP routes for our server application. More precisely, the server app is composed by two routes: The api route under the /api path, accepting all methods. The metrics routes under the /metrics path, accepting only GET requests. Other types of route groups and detailed information are available in the SMI specification . By default, all traffic is denied so we need to grant access to clients to our application. This is done by defining a TrafficTarget . TrafficTarget Source & Destination Please note that TrafficTarget is a namespaced resource. If the destination namespace is not populated, the TrafficTarget namespace will be used as the destination namespace. The source namespace must be populated, as it cannot be inferred. --- apiVersion: access.smi-spec.io/v1alpha1 kind: TrafficTarget metadata: name: client-server-target namespace: server destination: kind: ServiceAccount name: server namespace: server specs: - kind: HTTPRouteGroup name: server-routes matches: - api sources: - kind: ServiceAccount name: client namespace: client In this example, we grant access to all pods running with the service account client under the namespace client to the HTTP route api specified by on the group server-routes on all pods running with the service account server under the namespace server . Any client running with the service account client under the client namespace accessing server.server.maesh/api is allowed to access the /api resource. Others will receive 404 answers from the Maesh node. More information can be found in the SMI specification . Traffic Splitting \u00b6 SMI defines the TrafficSplit resource which allows to direct subsets of the traffic to different services. apiVersion: split.smi-spec.io/v1alpha2 kind: TrafficSplit metadata: name: server-split namespace: server spec: service: server backends: - service: server-v1 weight: 80 - service: server-v2 weight: 20 In this example, we define a traffic split for our server service between two versions of our server, v1 and v2. server.server.maesh directs 80% of the traffic to the server-v1 pods, and 20% of the traffic to the server-v2 pods. More information can be found in the SMI specification . Traffic Metrics \u00b6 At the moment, Maesh does not implement the Traffic Metrics specification .","title":"Configuration"},{"location":"configuration/#configuration","text":"The configuration for Maesh is broken down into two parts: the static configuration, and the dynamic configuration. The static configuration is configured when the service mesh is installed and is configured via the values.yaml file in the Helm install.","title":"Configuration"},{"location":"configuration/#static-configuration","text":"The Maesh image version can be manually defined if needed. Logging level and format for controller and proxies can be defined. The default mesh mode can be configured. If this is not set, the default mode will be HTTP. This means that new mesh services that are not specified will default to operate in HTTP mode. Tracing can be enabled. Access-Control List (ACL) mode can be enabled. This configures Maesh to run in ACL mode, where all traffic is forbidden unless explicitly allowed via an SMI TrafficTarget . Please see the SMI Specification for more information.","title":"Static configuration"},{"location":"configuration/#dynamic-configuration","text":"Dynamic configuration can be provided to Maesh using annotations on Kubernetes services and via SMI objects. Features ACL disabled ACL enabled Traffic-Type \u2714 \u2714 Scheme \u2714 \u2714 Retry \u2714 \u2714 Circuit-Breaker \u2714 \u2714 Rate-Limit \u2714 \u2714 Traffic-Split (SMI) \u2714 \u2714 Traffic-Target (SMI) \u2718 \u2714","title":"Dynamic configuration"},{"location":"configuration/#kubernetes-service-annotations","text":"Annotations on services give the ability to configure how Maesh interprets them.","title":"Kubernetes Service Annotations"},{"location":"configuration/#traffic-type","text":"The traffic type can be configured by using the following annotation: maesh.containo.us/traffic-type: \"http\" This annotation can be set to either http , tcp or udp and will specifies the mode for that service operation. If this annotation is not present, the mesh service will operate in the default mode specified in the static configuration. Info For now, the udp traffic type does not work when ACL mode is enabled. In ACL mode, all traffic is forbidden unless it is explicitly allowed with a TrafficTarget and unfortunately the SMI specification does not yet define a Traffic Spec for UDP .","title":"Traffic type"},{"location":"configuration/#scheme","text":"The scheme used to define custom scheme for request: maesh.containo.us/scheme: \"h2c\" This annotation can be set to either http , https or h2c and is available for maesh.containo.us/traffic-type: \"http\" . Limitations Please keep in mind, that if you set the scheme to https your service needs to expose itself via HTTPS as there is no mTLS in Maesh.","title":"Scheme"},{"location":"configuration/#retry","text":"Retries can be enabled by using the following annotation: maesh.containo.us/retry-attempts: \"2\" This annotation sets the number of retry attempts that Maesh will make if a network error occurs. Please note that this value is a string, and needs to be quoted.","title":"Retry"},{"location":"configuration/#circuit-breaker","text":"Circuit breaker can be enabled by using the following annotation: maesh.containo.us/circuit-breaker-expression: \"Expression\" This annotation sets the expression for circuit breaking. The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is closed (normal operations). When your system becomes unhealthy, the circuit opens, and requests are no longer forwarded (but handled by a fallback mechanism). All configuration options are available here .","title":"Circuit breaker"},{"location":"configuration/#rate-limit","text":"Rate limiting can be enabled by using the following annotations: maesh.containo.us/ratelimit-average: \"100\" maesh.containo.us/ratelimit-burst: \"200\" These annotation sets average and burst requests per second limit for the service. Please note that this value is a string, and needs to be quoted. Further details about the rate limiting can be found here .","title":"Rate Limit"},{"location":"configuration/#service-mesh-interface","text":"","title":"Service Mesh Interface"},{"location":"configuration/#access-control","text":"The first step is to describe what the traffic of our server application looks like. --- apiVersion: specs.smi-spec.io/v1alpha1 kind: HTTPRouteGroup metadata: name: server-routes namespace: server matches: - name: api pathRegex: /api methods: [\"*\"] - name: metrics pathRegex: /metrics methods: [\"GET\"] In this example, we define a set of HTTP routes for our server application. More precisely, the server app is composed by two routes: The api route under the /api path, accepting all methods. The metrics routes under the /metrics path, accepting only GET requests. Other types of route groups and detailed information are available in the SMI specification . By default, all traffic is denied so we need to grant access to clients to our application. This is done by defining a TrafficTarget . TrafficTarget Source & Destination Please note that TrafficTarget is a namespaced resource. If the destination namespace is not populated, the TrafficTarget namespace will be used as the destination namespace. The source namespace must be populated, as it cannot be inferred. --- apiVersion: access.smi-spec.io/v1alpha1 kind: TrafficTarget metadata: name: client-server-target namespace: server destination: kind: ServiceAccount name: server namespace: server specs: - kind: HTTPRouteGroup name: server-routes matches: - api sources: - kind: ServiceAccount name: client namespace: client In this example, we grant access to all pods running with the service account client under the namespace client to the HTTP route api specified by on the group server-routes on all pods running with the service account server under the namespace server . Any client running with the service account client under the client namespace accessing server.server.maesh/api is allowed to access the /api resource. Others will receive 404 answers from the Maesh node. More information can be found in the SMI specification .","title":"Access Control"},{"location":"configuration/#traffic-splitting","text":"SMI defines the TrafficSplit resource which allows to direct subsets of the traffic to different services. apiVersion: split.smi-spec.io/v1alpha2 kind: TrafficSplit metadata: name: server-split namespace: server spec: service: server backends: - service: server-v1 weight: 80 - service: server-v2 weight: 20 In this example, we define a traffic split for our server service between two versions of our server, v1 and v2. server.server.maesh directs 80% of the traffic to the server-v1 pods, and 20% of the traffic to the server-v2 pods. More information can be found in the SMI specification .","title":"Traffic Splitting"},{"location":"configuration/#traffic-metrics","text":"At the moment, Maesh does not implement the Traffic Metrics specification .","title":"Traffic Metrics"},{"location":"examples/","text":"Examples \u00b6 Here are some examples on how to easily deploy Maesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Maesh . Simple Example \u00b6 Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: containous/whoami:v1.4.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: containous/whoamitcp:latest imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Maesh by following this documentation on your cluster. Since Maesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Maesh since no X-Forwarded-For header should be added. Now, in order to configure Maesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have maesh.containo.us/traffic-type: \"http\" and the TCP service, maesh.containo.us/traffic-type: \"tcp\" . apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"http\" maesh.containo.us/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Maesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.maesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6 ACL Example \u00b6 The ACL mode can be enabled when installing Maesh. Once activated, all traffic is forbidden unless explicitly authorized using the SMI TrafficTarget resource. This example will present the configuration required to allow the client pod to send traffic to the HTTP and TCP services defined in the previous example. Each TrafficTarget defines that a set of source ServiceAccount is capable of sending traffic to a destination ServiceAccount . To authorize the whoami-client pod to send traffic to whoami.whoami.maesh , we need to explicitly allow it to hit the pods exposed by the whoami service. apiVersion: specs.smi-spec.io/v1alpha1 kind: HTTPRouteGroup metadata: name: http-everything namespace: whoami matches: - name: everything pathRegex: \".*\" methods: [\"*\"] --- kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha1 metadata: name: whatever namespace: whoami destination: kind: ServiceAccount name: whoami-server namespace: whoami port: \"80\" specs: - kind: HTTPRouteGroup name: http-everything matches: - everything sources: - kind: ServiceAccount name: whoami-client namespace: whoami Incoming traffic on a TCP service can also be authorized using a TrafficTarget and a TCPRoute . kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha1 metadata: name: api-service-target namespace: default destination: kind: ServiceAccount name: api-service namespace: default specs: - kind: TCPRoute name: my-tcp-route sources: - kind: ServiceAccount name: my-other-service namespace: default --- apiVersion: specs.smi-spec.io/v1alpha1 kind: TCPRoute metadata: name: my-tcp-route","title":"Examples"},{"location":"examples/#examples","text":"Here are some examples on how to easily deploy Maesh on your cluster. Prerequisites Before following those examples, make sure your cluster follows the prerequisites for deploying Maesh .","title":"Examples"},{"location":"examples/#simple-example","text":"Deploy those two yaml files on your Kubernetes cluster in order to add a simple backend example, available through HTTP and TCP. namespace.yaml apiVersion: v1 kind: Namespace metadata: name: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-server namespace: whoami --- apiVersion: v1 kind: ServiceAccount metadata: name: whoami-client namespace: whoami deployment.yaml --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: serviceAccount: whoami-server containers: - name: whoami image: containous/whoami:v1.4.0 imagePullPolicy: IfNotPresent --- kind: Deployment apiVersion: apps/v1 metadata: name: whoami-tcp namespace: whoami spec: replicas: 2 selector: matchLabels: app: whoami-tcp template: metadata: labels: app: whoami-tcp spec: serviceAccount: whoami-server containers: - name: whoami-tcp image: containous/whoamitcp:latest imagePullPolicy: IfNotPresent --- apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp --- apiVersion: v1 kind: Pod metadata: name: whoami-client namespace: whoami spec: serviceAccountName: whoami-client containers: - name: whoami-client image: giantswarm/tiny-tools:3.9 command: - \"sleep\" - \"3600\" You should now see the following when running kubectl get all -n whoami : NAME READY STATUS RESTARTS AGE pod/whoami-client 1/1 Running 0 11s pod/whoami-f4cbd7f9c-lddgq 1/1 Running 0 12s pod/whoami-f4cbd7f9c-zk4rb 1/1 Running 0 12s pod/whoami-tcp-7679bc465-ldlt2 1/1 Running 0 12s pod/whoami-tcp-7679bc465-wf87n 1/1 Running 0 12s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/whoami ClusterIP 100.68.109.244 <none> 80/TCP 13s service/whoami-tcp ClusterIP 100.68.73.211 <none> 8080/TCP 13s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/whoami 2 2 2 2 13s deployment.apps/whoami-tcp 2 2 2 2 13s NAME DESIRED CURRENT READY AGE replicaset.apps/whoami-f4cbd7f9c 2 2 2 13s replicaset.apps/whoami-tcp-7679bc465 2 2 2 13s You should now be able to make direct requests on your whoami service through HTTP. Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.svc.cluster.local Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* And through TCP, by executing the following netcat command and sending some data. Command kubectl -n whoami exec -ti whoami-client -- nc whoami-tcp.whoami.svc.cluster.local 8080 my data Expected Output Received: my data You can now install Maesh by following this documentation on your cluster. Since Maesh is not intrusive, it has to be explicitly given access to services before it can be used. You can ensure that the HTTP endpoint of your service does not pass through Maesh since no X-Forwarded-For header should be added. Now, in order to configure Maesh for your whoami service, you just need to update the whoami service specs, in order to add the appropriate annotations. The HTTP service needs to have maesh.containo.us/traffic-type: \"http\" and the TCP service, maesh.containo.us/traffic-type: \"tcp\" . apiVersion: v1 kind: Service metadata: name: whoami namespace: whoami labels: app: whoami # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"http\" maesh.containo.us/retry-attempts: \"2\" spec: type: ClusterIP ports: - port: 80 name: whoami selector: app: whoami --- apiVersion: v1 kind: Service metadata: name: whoami-tcp namespace: whoami labels: app: whoami-tcp # These annotations enable Maesh for this service: annotations: maesh.containo.us/traffic-type: \"tcp\" spec: type: ClusterIP ports: - port: 8080 name: whoami-tcp selector: app: whoami-tcp You should now be able to access your HTTP and TCP services through the Maesh endpoint: Command kubectl -n whoami exec whoami-client -- curl -s whoami.whoami.maesh Expected Output Hostname: whoami-84bdf87956-gvbm8 IP: 127.0.0.1 IP: 5.6.7.8 RemoteAddr: 1.2.3.4:12345 GET / HTTP/1.1 Host: whoami.whoami.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* X-Forwarded-For: 3.4.5.6","title":"Simple Example"},{"location":"examples/#acl-example","text":"The ACL mode can be enabled when installing Maesh. Once activated, all traffic is forbidden unless explicitly authorized using the SMI TrafficTarget resource. This example will present the configuration required to allow the client pod to send traffic to the HTTP and TCP services defined in the previous example. Each TrafficTarget defines that a set of source ServiceAccount is capable of sending traffic to a destination ServiceAccount . To authorize the whoami-client pod to send traffic to whoami.whoami.maesh , we need to explicitly allow it to hit the pods exposed by the whoami service. apiVersion: specs.smi-spec.io/v1alpha1 kind: HTTPRouteGroup metadata: name: http-everything namespace: whoami matches: - name: everything pathRegex: \".*\" methods: [\"*\"] --- kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha1 metadata: name: whatever namespace: whoami destination: kind: ServiceAccount name: whoami-server namespace: whoami port: \"80\" specs: - kind: HTTPRouteGroup name: http-everything matches: - everything sources: - kind: ServiceAccount name: whoami-client namespace: whoami Incoming traffic on a TCP service can also be authorized using a TrafficTarget and a TCPRoute . kind: TrafficTarget apiVersion: access.smi-spec.io/v1alpha1 metadata: name: api-service-target namespace: default destination: kind: ServiceAccount name: api-service namespace: default specs: - kind: TCPRoute name: my-tcp-route sources: - kind: ServiceAccount name: my-other-service namespace: default --- apiVersion: specs.smi-spec.io/v1alpha1 kind: TCPRoute metadata: name: my-tcp-route","title":"ACL Example"},{"location":"install/","text":"Installation \u00b6 To install Maesh, the installation method is quite simple: helm repo add maesh https://containous.github.io/maesh/charts helm repo update Install Maesh Helm Chart: helm install maesh maesh/maesh Install from source \u00b6 Supported Installations Please be aware that the supported installation method is via Helm, using official releases. If you want to build/install/run Maesh from source, we may not be able to provide support. Installing from source is intended for development/contributing. To build the image locally, run: make You will then be able to use the tagged image as your image in your values.yaml file. Deploy Helm Chart \u00b6 To deploy the Helm Chart, run: helm install maesh helm/chart/maesh --set image.pullPolicy=IfNotPresent --set image.tag=latest KubeDNS support \u00b6 Maesh supports KubeDNS: helm install maesh maesh/maesh --set kubedns=true With the kubedns parameter Maesh will install CoreDNS and patch KubeDNS to use it as a stubDomain . Custom cluster domain \u00b6 If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install maesh maesh/maesh --set clusterDomain=my.custom.domain.com Access Control List \u00b6 By default, Maesh does not restrict traffic between pods and services. However, some scenarios require more control over the rules for internal communication. The Access Control List mode (ACL) requires a set of rules to explicitly allow traffic between different resources. To enable ACL, install Maesh in ACL mode by setting the acl Helm Chart option to true . helm install maesh --namespace=maesh maesh/maesh --set acl=true Maesh supports the SMI specification which defines a set of custom resources to provide a fine-grained control over instrumentation, routing and access control of east-west communications. CRDs Helm v3 will install automatically the CRDs in the /crds directory. If you are (re)installing into a cluster with the CRDs already present, Helm may print a warning. If you do not want to install them, or want to avoid the warning, use the new --skip-crds flag. More information can be found in the Helm documentation . Platform recommendations \u00b6 Maesh works on Kubernetes environments that conforms to the global Kubernetes specification. That being said, we have had users encounter issues when using variants such as minikube, microk8s, and other development distributions. Maesh runs without issue on most public clouds (AWS, GKE, Azure, DigitalOcean, and more). If you want to run Maesh in development, we would recommend using k3s , as it is fully conformant. We use k3s in Maesh's integration tests, so you can be sure that it works properly. If you encounter issues on variants such as minikube or microk8s, please try and reproduce the issue on k3s. If you are unable to reproduce, it may be an issue with the distribution behaving differently than official Kubernetes. Verify your installation \u00b6 You can check that Maesh has been installed properly by running the following command: Command kubectl get all -n maesh Expected Output NAME READY STATUS RESTARTS AGE pod/maesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/maesh-mesh-w62z5 1/1 Running 0 11s pod/maesh-mesh-zjlpf 1/1 Running 0 11s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/maesh-mesh-api ClusterIP 100.69.177.254 <none> 8080/TCP 29s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/maesh-mesh 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/maesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/maesh-controller-676fb86b89 1 1 0 28s Usage \u00b6 To use Maesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.maesh . This will access the Maesh service mesh, and will allow you to route requests through Maesh. By default, Maesh is opt-in, meaning you have to use the Maesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Installation"},{"location":"install/#installation","text":"To install Maesh, the installation method is quite simple: helm repo add maesh https://containous.github.io/maesh/charts helm repo update Install Maesh Helm Chart: helm install maesh maesh/maesh","title":"Installation"},{"location":"install/#install-from-source","text":"Supported Installations Please be aware that the supported installation method is via Helm, using official releases. If you want to build/install/run Maesh from source, we may not be able to provide support. Installing from source is intended for development/contributing. To build the image locally, run: make You will then be able to use the tagged image as your image in your values.yaml file.","title":"Install from source"},{"location":"install/#deploy-helm-chart","text":"To deploy the Helm Chart, run: helm install maesh helm/chart/maesh --set image.pullPolicy=IfNotPresent --set image.tag=latest","title":"Deploy Helm Chart"},{"location":"install/#kubedns-support","text":"Maesh supports KubeDNS: helm install maesh maesh/maesh --set kubedns=true With the kubedns parameter Maesh will install CoreDNS and patch KubeDNS to use it as a stubDomain .","title":"KubeDNS support"},{"location":"install/#custom-cluster-domain","text":"If you use a cluster domain other than cluster.local set it by using the clusterDomain parameter: helm install maesh maesh/maesh --set clusterDomain=my.custom.domain.com","title":"Custom cluster domain"},{"location":"install/#access-control-list","text":"By default, Maesh does not restrict traffic between pods and services. However, some scenarios require more control over the rules for internal communication. The Access Control List mode (ACL) requires a set of rules to explicitly allow traffic between different resources. To enable ACL, install Maesh in ACL mode by setting the acl Helm Chart option to true . helm install maesh --namespace=maesh maesh/maesh --set acl=true Maesh supports the SMI specification which defines a set of custom resources to provide a fine-grained control over instrumentation, routing and access control of east-west communications. CRDs Helm v3 will install automatically the CRDs in the /crds directory. If you are (re)installing into a cluster with the CRDs already present, Helm may print a warning. If you do not want to install them, or want to avoid the warning, use the new --skip-crds flag. More information can be found in the Helm documentation .","title":"Access Control List"},{"location":"install/#platform-recommendations","text":"Maesh works on Kubernetes environments that conforms to the global Kubernetes specification. That being said, we have had users encounter issues when using variants such as minikube, microk8s, and other development distributions. Maesh runs without issue on most public clouds (AWS, GKE, Azure, DigitalOcean, and more). If you want to run Maesh in development, we would recommend using k3s , as it is fully conformant. We use k3s in Maesh's integration tests, so you can be sure that it works properly. If you encounter issues on variants such as minikube or microk8s, please try and reproduce the issue on k3s. If you are unable to reproduce, it may be an issue with the distribution behaving differently than official Kubernetes.","title":"Platform recommendations"},{"location":"install/#verify-your-installation","text":"You can check that Maesh has been installed properly by running the following command: Command kubectl get all -n maesh Expected Output NAME READY STATUS RESTARTS AGE pod/maesh-controller-676fb86b89-pj8ph 1/1 Running 0 11s pod/maesh-mesh-w62z5 1/1 Running 0 11s pod/maesh-mesh-zjlpf 1/1 Running 0 11s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/maesh-mesh-api ClusterIP 100.69.177.254 <none> 8080/TCP 29s NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.apps/maesh-mesh 2 2 0 2 0 <none> 29s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deployment.apps/maesh-controller 1 1 1 0 28s NAME DESIRED CURRENT READY AGE replicaset.apps/maesh-controller-676fb86b89 1 1 0 28s","title":"Verify your installation"},{"location":"install/#usage","text":"To use Maesh, instead of referencing services via their normal <servicename>.<namespace> , instead use <servicename>.<namespace>.maesh . This will access the Maesh service mesh, and will allow you to route requests through Maesh. By default, Maesh is opt-in, meaning you have to use the Maesh service names to access the mesh, so you can have some services running through the mesh, and some services not.","title":"Usage"},{"location":"quickstart/","text":"Quickstart \u00b6 Maesh can be installed in your cluster without affecting any running services. It can safely be installed using the Helm Chart . Prerequisites \u00b6 Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3 RBAC \u00b6 Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions. kubeadm \u00b6 If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system Installing Maesh \u00b6 Command helm repo add maesh https://containous.github.io/maesh/charts helm repo update helm install maesh maesh/maesh Expected output [...] NOTES: Thank you for installing maesh. Your release is named maesh. To learn more about the release, try: $ helm status maesh $ helm get maesh Using Maesh \u00b6 As an example, let's deploy a server application and a client application under the maesh-test namespace. server.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: server namespace: maesh-test labels: app: server spec: replicas: 2 selector: matchLabels: app: server template: metadata: labels: app: server spec: containers: - name: server image: containous/whoami:v1.4.0 ports: - containerPort: 80 --- kind: Service apiVersion: v1 metadata: name: server namespace: maesh-test spec: selector: app: server ports: - name: web protocol: TCP port: 80 targetPort: 80 client.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: client namespace: maesh-test labels: app: client spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: giantswarm/tiny-tools:3.9 imagePullPolicy: IfNotPresent command: - \"sleep\" - \"infinity\" Create the namespace then deploy those two applications: kubectl create namespace maesh-test kubectl apply -f server.yaml kubectl apply -f client.yaml You should now see the following output: Command kubectl get all -n maesh-test Expected output NAME READY STATUS RESTARTS AGE pod/client-7446fdf848-x96fq 1/1 Running 0 79s pod/server-7c8fd58db5-rchg8 1/1 Running 0 77s pod/server-7c8fd58db5-sd4f9 1/1 Running 0 77s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/server ClusterIP 10.43.17.247 <none> 80/TCP 77s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/client 1/1 1 1 79s deployment.apps/server 2/2 2 2 77s NAME DESIRED CURRENT READY AGE replicaset.apps/client-7446fdf848 1 1 1 79s replicaset.apps/server-7c8fd58db5 2 2 2 77s Take note of the client app pod name (here it's client-7446fdf848-x96fq ) and open a new terminal session inside this pod using kubectl exec . kubectl -n maesh-test exec -ti client-7446fdf848-x96fq ash From inside the client container, make sure your server is reachable using the Kubernetes DNS service discovery. Command curl server.maesh-test.svc.cluster.local Expected Output Hostname: server-7c8fd58db5-sd4f9 IP: 127.0.0.1 IP: ::1 IP: 10.42.2.10 IP: fe80::a4ec:77ff:fe37:1cdd RemoteAddr: 10.42.2.9:46078 GET / HTTP/1.1 Host: server.maesh-test.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* You can note that all this server application is doing is to respond with the content of the request it receives. Now replace the svc.cluster.local suffix by maesh , and tada: you are now using Maesh to reach your server! Command curl server.maesh-test.maesh Expected Output Hostname: server-7c8fd58db5-rchg8 IP: 127.0.0.1 IP: ::1 IP: 10.42.1.7 IP: fe80::601d:7cff:fe26:c8c6 RemoteAddr: 10.42.1.5:59478 GET / HTTP/1.1 Host: server.maesh-test.maesh User-Agent: curl/7.64.0 Accept: */* Accept-Encoding: gzip Uber-Trace-Id: 3f9e7129a059f70:7e889a1ebcb147ac:3f9e7129a059f70:1 X-Forwarded-For: 10.42.2.9 X-Forwarded-Host: server.maesh-test.maesh X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: maesh-mesh-w95q2 X-Real-Ip: 10.42.2.9 Note the presence of X-Forwarded headers as well as other instrumentation headers like Uber-Trace-Id , indicating than your request has been processed and instrumented by Maesh. What's next \u00b6 See the examples page to see a more advanced example, or dive into the configuration to discover all Maesh capabilities.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Maesh can be installed in your cluster without affecting any running services. It can safely be installed using the Helm Chart .","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"Kubernetes 1.11+ CoreDNS installed as Cluster DNS Provider (versions 1.3+ supported) Helm v3","title":"Prerequisites"},{"location":"quickstart/#rbac","text":"Depending on the tool you used to deploy your cluster you might need to tweak RBAC permissions.","title":"RBAC"},{"location":"quickstart/#kubeadm","text":"If you used kubeadm to deploy your cluster, a fast way to allow the helm installation to perform all steps it needs is to edit the cluster-admin ClusterRoleBinding , adding the following to the subjects section: - kind: ServiceAccount name: default namespace: kube-system","title":"kubeadm"},{"location":"quickstart/#installing-maesh","text":"Command helm repo add maesh https://containous.github.io/maesh/charts helm repo update helm install maesh maesh/maesh Expected output [...] NOTES: Thank you for installing maesh. Your release is named maesh. To learn more about the release, try: $ helm status maesh $ helm get maesh","title":"Installing Maesh"},{"location":"quickstart/#using-maesh","text":"As an example, let's deploy a server application and a client application under the maesh-test namespace. server.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: server namespace: maesh-test labels: app: server spec: replicas: 2 selector: matchLabels: app: server template: metadata: labels: app: server spec: containers: - name: server image: containous/whoami:v1.4.0 ports: - containerPort: 80 --- kind: Service apiVersion: v1 metadata: name: server namespace: maesh-test spec: selector: app: server ports: - name: web protocol: TCP port: 80 targetPort: 80 client.yaml --- apiVersion: apps/v1 kind: Deployment metadata: name: client namespace: maesh-test labels: app: client spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: giantswarm/tiny-tools:3.9 imagePullPolicy: IfNotPresent command: - \"sleep\" - \"infinity\" Create the namespace then deploy those two applications: kubectl create namespace maesh-test kubectl apply -f server.yaml kubectl apply -f client.yaml You should now see the following output: Command kubectl get all -n maesh-test Expected output NAME READY STATUS RESTARTS AGE pod/client-7446fdf848-x96fq 1/1 Running 0 79s pod/server-7c8fd58db5-rchg8 1/1 Running 0 77s pod/server-7c8fd58db5-sd4f9 1/1 Running 0 77s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/server ClusterIP 10.43.17.247 <none> 80/TCP 77s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/client 1/1 1 1 79s deployment.apps/server 2/2 2 2 77s NAME DESIRED CURRENT READY AGE replicaset.apps/client-7446fdf848 1 1 1 79s replicaset.apps/server-7c8fd58db5 2 2 2 77s Take note of the client app pod name (here it's client-7446fdf848-x96fq ) and open a new terminal session inside this pod using kubectl exec . kubectl -n maesh-test exec -ti client-7446fdf848-x96fq ash From inside the client container, make sure your server is reachable using the Kubernetes DNS service discovery. Command curl server.maesh-test.svc.cluster.local Expected Output Hostname: server-7c8fd58db5-sd4f9 IP: 127.0.0.1 IP: ::1 IP: 10.42.2.10 IP: fe80::a4ec:77ff:fe37:1cdd RemoteAddr: 10.42.2.9:46078 GET / HTTP/1.1 Host: server.maesh-test.svc.cluster.local User-Agent: curl/7.64.0 Accept: */* You can note that all this server application is doing is to respond with the content of the request it receives. Now replace the svc.cluster.local suffix by maesh , and tada: you are now using Maesh to reach your server! Command curl server.maesh-test.maesh Expected Output Hostname: server-7c8fd58db5-rchg8 IP: 127.0.0.1 IP: ::1 IP: 10.42.1.7 IP: fe80::601d:7cff:fe26:c8c6 RemoteAddr: 10.42.1.5:59478 GET / HTTP/1.1 Host: server.maesh-test.maesh User-Agent: curl/7.64.0 Accept: */* Accept-Encoding: gzip Uber-Trace-Id: 3f9e7129a059f70:7e889a1ebcb147ac:3f9e7129a059f70:1 X-Forwarded-For: 10.42.2.9 X-Forwarded-Host: server.maesh-test.maesh X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: maesh-mesh-w95q2 X-Real-Ip: 10.42.2.9 Note the presence of X-Forwarded headers as well as other instrumentation headers like Uber-Trace-Id , indicating than your request has been processed and instrumented by Maesh.","title":"Using Maesh"},{"location":"quickstart/#whats-next","text":"See the examples page to see a more advanced example, or dive into the configuration to discover all Maesh capabilities.","title":"What's next"},{"location":"contributing/building-testing/","text":"Building and Testing \u00b6 So you want to build your own Maesh binary from the sources? Let's see how. Building \u00b6 To build Maesh from the sources you need either Docker and make , or Go . With Docker and make \u00b6 Maesh can be built from the sources by using the make command. This will create a binary for the Linux platform in the dist directory and a Docker image: $ make #[...] Successfully tagged containous/maesh:latest docker run --name=build -t \"containous/maesh:latest\" version version: version : 04789a3 commit : 04789a3 build date : 2020-04-09_10:24:49AM go version : go1.14.1 go compiler : gc platform : linux/amd64 #[...] $ ls dist/ maesh Note The default make target invokes the clean , check , test and build targets. With Go \u00b6 Requirements: Go v1.14+ Environment variable GO111MODULE=on One your Go environment is set up, you can build Maesh from the sources by using the go build command. The Go compiler will build an executable for your platform. $ go build -o dist/maesh cmd/maesh/*.go $ ./dist/maesh version version: version : dev commit : I don't remember exactly build date : I don't remember exactly go version : go1.14.1 go compiler : gc platform : darwin/amd64 Testing \u00b6 With Docker and make \u00b6 Run unit tests by using the test target: $ make test docker build --tag \"containous/maesh:test\" --target maker --build-arg=\"MAKE_TARGET=local-test\" /home/user/maesh/ #[...] --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.20s) PASS coverage: 69.7% of statements ok github.com/containous/maesh/pkg/providers/smi 1.982s coverage: 69.7% of statements ? github.com/containous/maesh/pkg/signals [no test files] Removing intermediate container 4e887c16ddee ---> 75d44229a46e Successfully built 75d44229a46e Successfully tagged containous/maesh:test Run the integration tests by using the test-integration target. For development purposes, you can specify which tests to run by using the TESTFLAGS environment variable (only works with the test-integration target): # Run every tests in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More on https://labix.org/gocheck . With Go \u00b6 Run the unit tests by using the go test command: $ go test -v ./... #[...] === RUN TestGroupTrafficTargetsByDestination --- PASS: TestGroupTrafficTargetsByDestination (0.20s) === RUN TestBuildConfiguration === RUN TestBuildConfiguration/simple_configuration_build_with_HTTP_service === PAUSE TestBuildConfiguration/simple_configuration_build_with_HTTP_service === CONT TestBuildConfiguration/simple_configuration_build_with_HTTP_service time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found applicable traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found grouped traffictargets for service default/demo-service: map[{name:api-service namespace:default port:}:[0xc000900820]]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"No TrafficSplits in namespace: default\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found trafficsplits for service default/demo-service: []\" --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.21s) PASS ok github.com/containous/maesh/pkg/providers/smi 3.634s ? github.com/containous/maesh/pkg/signals [no test files] Run the integration tests in the integration directory by using the go test ./integration -integration command: $ go test -v ./integration -integration -check.f HelmSuite #[...] OK: 2 passed --- PASS: Test (161.20s) PASS ok github.com/containous/maesh/integration 162.695s Important Before running the integration tests, build the Maesh Docker image. Check out the Building section for more details.","title":"Building and Testing"},{"location":"contributing/building-testing/#building-and-testing","text":"So you want to build your own Maesh binary from the sources? Let's see how.","title":"Building and Testing"},{"location":"contributing/building-testing/#building","text":"To build Maesh from the sources you need either Docker and make , or Go .","title":"Building"},{"location":"contributing/building-testing/#with-docker-and-make","text":"Maesh can be built from the sources by using the make command. This will create a binary for the Linux platform in the dist directory and a Docker image: $ make #[...] Successfully tagged containous/maesh:latest docker run --name=build -t \"containous/maesh:latest\" version version: version : 04789a3 commit : 04789a3 build date : 2020-04-09_10:24:49AM go version : go1.14.1 go compiler : gc platform : linux/amd64 #[...] $ ls dist/ maesh Note The default make target invokes the clean , check , test and build targets.","title":"With Docker and make"},{"location":"contributing/building-testing/#with-go","text":"Requirements: Go v1.14+ Environment variable GO111MODULE=on One your Go environment is set up, you can build Maesh from the sources by using the go build command. The Go compiler will build an executable for your platform. $ go build -o dist/maesh cmd/maesh/*.go $ ./dist/maesh version version: version : dev commit : I don't remember exactly build date : I don't remember exactly go version : go1.14.1 go compiler : gc platform : darwin/amd64","title":"With Go"},{"location":"contributing/building-testing/#testing","text":"","title":"Testing"},{"location":"contributing/building-testing/#with-docker-and-make_1","text":"Run unit tests by using the test target: $ make test docker build --tag \"containous/maesh:test\" --target maker --build-arg=\"MAKE_TARGET=local-test\" /home/user/maesh/ #[...] --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.20s) PASS coverage: 69.7% of statements ok github.com/containous/maesh/pkg/providers/smi 1.982s coverage: 69.7% of statements ? github.com/containous/maesh/pkg/signals [no test files] Removing intermediate container 4e887c16ddee ---> 75d44229a46e Successfully built 75d44229a46e Successfully tagged containous/maesh:test Run the integration tests by using the test-integration target. For development purposes, you can specify which tests to run by using the TESTFLAGS environment variable (only works with the test-integration target): # Run every tests in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite $ TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More on https://labix.org/gocheck .","title":"With Docker and make"},{"location":"contributing/building-testing/#with-go_1","text":"Run the unit tests by using the go test command: $ go test -v ./... #[...] === RUN TestGroupTrafficTargetsByDestination --- PASS: TestGroupTrafficTargetsByDestination (0.20s) === RUN TestBuildConfiguration === RUN TestBuildConfiguration/simple_configuration_build_with_HTTP_service === PAUSE TestBuildConfiguration/simple_configuration_build_with_HTTP_service === CONT TestBuildConfiguration/simple_configuration_build_with_HTTP_service time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found applicable traffictargets for service default/demo-service: [0xc0009004e0]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found grouped traffictargets for service default/demo-service: map[{name:api-service namespace:default port:}:[0xc000900820]]\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"No TrafficSplits in namespace: default\" time=\"2020-04-09T16:09:16+04:00\" level=debug msg=\"Found trafficsplits for service default/demo-service: []\" --- PASS: TestBuildConfiguration (0.00s) --- PASS: TestBuildConfiguration/simple_configuration_build_with_HTTP_service (0.21s) PASS ok github.com/containous/maesh/pkg/providers/smi 3.634s ? github.com/containous/maesh/pkg/signals [no test files] Run the integration tests in the integration directory by using the go test ./integration -integration command: $ go test -v ./integration -integration -check.f HelmSuite #[...] OK: 2 passed --- PASS: Test (161.20s) PASS ok github.com/containous/maesh/integration 162.695s Important Before running the integration tests, build the Maesh Docker image. Check out the Building section for more details.","title":"With Go"},{"location":"contributing/documentation/","text":"Documentation \u00b6 You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how. Building \u00b6 This documentation is built with MkDocs . With Docker and make \u00b6 You can build the documentation and test it locally (with live reloading), using the serve target: $ make serve docker build -t maesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /Users/kevinpollet/Documents/Dev/maesh/docs:/mkdocs -p 8000:8000 maesh-docs mkdocs serve # [\u2026] INFO - Building documentation... INFO - Cleaning site directory [I 200408 14:36:33 server:296] Serving on http://0.0.0.0:8000 [I 200408 14:36:33 handlers:62] Start watching changes [I 200408 14:36:33 handlers:64] Start detecting changes Note By default, the local documentation server listens on http://127.0.0.1:8000 . To build the documentation without serving it locally, use the build target. With MkDocs \u00b6 First, make sure you have python and pip installed. MkDocs supports python versions 2.7.9+ , 3.4 , 3.5 , 3.6 and 3.7 . $ python --version Python 2.7.14 $ pip --version pip 19.3.1 from /usr/local/lib/python2.7/site-packages/pip (python 2.7) Then, install MkDocs with pip . pip install --user -r requirements.txt To build the documentation and serve it locally, run mkdocs serve from the root directory. This starts a local server, and exposes the documentation on http://127.0.0.1:8000 : $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes Checking \u00b6 To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the verify target. If you've made changes to the documentation, it's safer to clean it before verifying it. $ make clean verify docker build -t maesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /Users/kevinpollet/Documents/Dev/maesh/docs:/mkdocs -p 8000:8000 maesh-docs sh -c \"mkdocs build && chown -R 501:20 ./site\" === Checking HTML content... # [\u2026] Disabling Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : $ DOCS_VERIFY_SKIP=true make verify # [\u2026] DOCS_VERIFY_SKIP is true: no verification done.","title":"Documentation"},{"location":"contributing/documentation/#documentation","text":"You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how.","title":"Documentation"},{"location":"contributing/documentation/#building","text":"This documentation is built with MkDocs .","title":"Building"},{"location":"contributing/documentation/#with-docker-and-make","text":"You can build the documentation and test it locally (with live reloading), using the serve target: $ make serve docker build -t maesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /Users/kevinpollet/Documents/Dev/maesh/docs:/mkdocs -p 8000:8000 maesh-docs mkdocs serve # [\u2026] INFO - Building documentation... INFO - Cleaning site directory [I 200408 14:36:33 server:296] Serving on http://0.0.0.0:8000 [I 200408 14:36:33 handlers:62] Start watching changes [I 200408 14:36:33 handlers:64] Start detecting changes Note By default, the local documentation server listens on http://127.0.0.1:8000 . To build the documentation without serving it locally, use the build target.","title":"With Docker and make"},{"location":"contributing/documentation/#with-mkdocs","text":"First, make sure you have python and pip installed. MkDocs supports python versions 2.7.9+ , 3.4 , 3.5 , 3.6 and 3.7 . $ python --version Python 2.7.14 $ pip --version pip 19.3.1 from /usr/local/lib/python2.7/site-packages/pip (python 2.7) Then, install MkDocs with pip . pip install --user -r requirements.txt To build the documentation and serve it locally, run mkdocs serve from the root directory. This starts a local server, and exposes the documentation on http://127.0.0.1:8000 : $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes","title":"With MkDocs"},{"location":"contributing/documentation/#checking","text":"To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the verify target. If you've made changes to the documentation, it's safer to clean it before verifying it. $ make clean verify docker build -t maesh-docs -f docs.Dockerfile ./ # [\u2026] docker run --rm -v /Users/kevinpollet/Documents/Dev/maesh/docs:/mkdocs -p 8000:8000 maesh-docs sh -c \"mkdocs build && chown -R 501:20 ./site\" === Checking HTML content... # [\u2026] Disabling Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : $ DOCS_VERIFY_SKIP=true make verify # [\u2026] DOCS_VERIFY_SKIP is true: no verification done.","title":"Checking"},{"location":"contributing/maintainers/","text":"Maintainers \u00b6 Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Micha\u00ebl Matur @mmatur Landry Benguigui @LandryBe Harold Ozouf @jspdown Julien Levesy @jlevesy Brendan Le Glaunec @Ullaakut Kevin Pollet @kevinpollet","title":"Maintainers"},{"location":"contributing/maintainers/#maintainers","text":"Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Micha\u00ebl Matur @mmatur Landry Benguigui @LandryBe Harold Ozouf @jspdown Julien Levesy @jlevesy Brendan Le Glaunec @Ullaakut Kevin Pollet @kevinpollet","title":"Maintainers"},{"location":"contributing/submitting-issues/","text":"Submitting Issues \u00b6 We use the GitHub issue tracker to keep track of Maesh issues. The process of sorting and checking the issues requires a lot of work. To save us some time and get quicker feedback, be sure to follow the guidelines below. Getting Help The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, use the Maesh community forum . Issue Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the issue template as much as possible. Explain in which context you encountered the issue. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). Feature Request \u00b6 Remember, when asking for new features, they must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do your best to explain what you're looking for, and why it would improve Maesh for everyone. International English \u00b6 Maesh maintainers/users are not all native English speakers, so if you sometimes feel that some messages sound rude, remember that it's probably a language barrier problem from someone willing to help you.","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#submitting-issues","text":"We use the GitHub issue tracker to keep track of Maesh issues. The process of sorting and checking the issues requires a lot of work. To save us some time and get quicker feedback, be sure to follow the guidelines below. Getting Help The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, use the Maesh community forum .","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#issue-title","text":"The title must be short and descriptive. (~60 characters)","title":"Issue Title"},{"location":"contributing/submitting-issues/#description","text":"Follow the issue template as much as possible. Explain in which context you encountered the issue. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-issues/#feature-request","text":"Remember, when asking for new features, they must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do your best to explain what you're looking for, and why it would improve Maesh for everyone.","title":"Feature Request"},{"location":"contributing/submitting-issues/#international-english","text":"Maesh maintainers/users are not all native English speakers, so if you sometimes feel that some messages sound rude, remember that it's probably a language barrier problem from someone willing to help you.","title":"International English"},{"location":"contributing/submitting-pull-requests/","text":"Submitting Pull Requests \u00b6 So you've decided to improve Maesh? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go through the classic pitfalls to make sure everything is right. Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). Content \u00b6 Make it small. Each PR should be linked to an issue. One feature per PR. PRs should be standalone (they should not depend on an upcoming PR). Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Commits should be split properly (in order to guide reviewers through the code). Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (don't amend/squash existing ones unless the PR is trivial).","title":"Submitting Pull Requests"},{"location":"contributing/submitting-pull-requests/#submitting-pull-requests","text":"So you've decided to improve Maesh? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go through the classic pitfalls to make sure everything is right.","title":"Submitting Pull Requests"},{"location":"contributing/submitting-pull-requests/#title","text":"The title must be short and descriptive. (~60 characters)","title":"Title"},{"location":"contributing/submitting-pull-requests/#description","text":"Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-pull-requests/#content","text":"Make it small. Each PR should be linked to an issue. One feature per PR. PRs should be standalone (they should not depend on an upcoming PR). Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Commits should be split properly (in order to guide reviewers through the code). Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (don't amend/squash existing ones unless the PR is trivial).","title":"Content"},{"location":"contributing/thank-you/","text":"Thank You! \u00b6 Maesh is an open-source project , your feedback and contributions are needed and always welcome! Where to Go Next? If you want to: Propose and idea, request a feature a report a bug, read the page Submitting Issues . Discover how to make an efficient contribution, read the page Submitting Pull Requests . Learn how to build and test Maesh, the page Building and Testing is for you. Contribute to the documentation, read the related page Documentation .","title":"Thank You!"},{"location":"contributing/thank-you/#thank-you","text":"Maesh is an open-source project , your feedback and contributions are needed and always welcome! Where to Go Next? If you want to: Propose and idea, request a feature a report a bug, read the page Submitting Issues . Discover how to make an efficient contribution, read the page Submitting Pull Requests . Learn how to build and test Maesh, the page Building and Testing is for you. Contribute to the documentation, read the related page Documentation .","title":"Thank You!"},{"location":"migration/helm-chart/","text":"Migrations \u00b6 Helm Chart v1.x to v2.0 \u00b6 Image version \u00b6 Since version v1.2 , Maesh uses Traefik as a library and does not rely on its Docker image anymore. Therefore, the controller.image and mesh.image options have been removed. You should use the new image option as described in the documentation . Log Level \u00b6 The controller.logging.debug and mesh.logging options have been removed. You should use the new controller.logLevel and mesh.logLevel options to configure the logging level for the controller and proxies. SMI Mode \u00b6 The smi.enable option has been deprecated and removed. You should use the new and backward compatible ACL mode option as described in the documentation . v2.0 to v2.1 \u00b6 Default Mode \u00b6 The controller.mesh.defaultMode option has been deprecated and will be removed in a future major release. You should use the new defaultMode option to configure the default traffic mode for Maesh services. Prometheus and Grafana services \u00b6 Prior to version v2.1 , when the Metrics chart is deployed, Prometheus and Grafana services are exposed by default through a NodePort . For security reasons, those services are not exposed by default anymore. To expose them you should use the new prometheus.service and grafana.service options, more details in the corresponding values.yaml .","title":"Helm Chart"},{"location":"migration/helm-chart/#migrations","text":"Helm Chart","title":"Migrations"},{"location":"migration/helm-chart/#v1x-to-v20","text":"","title":"v1.x to v2.0"},{"location":"migration/helm-chart/#image-version","text":"Since version v1.2 , Maesh uses Traefik as a library and does not rely on its Docker image anymore. Therefore, the controller.image and mesh.image options have been removed. You should use the new image option as described in the documentation .","title":"Image version"},{"location":"migration/helm-chart/#log-level","text":"The controller.logging.debug and mesh.logging options have been removed. You should use the new controller.logLevel and mesh.logLevel options to configure the logging level for the controller and proxies.","title":"Log Level"},{"location":"migration/helm-chart/#smi-mode","text":"The smi.enable option has been deprecated and removed. You should use the new and backward compatible ACL mode option as described in the documentation .","title":"SMI Mode"},{"location":"migration/helm-chart/#v20-to-v21","text":"","title":"v2.0 to v2.1"},{"location":"migration/helm-chart/#default-mode","text":"The controller.mesh.defaultMode option has been deprecated and will be removed in a future major release. You should use the new defaultMode option to configure the default traffic mode for Maesh services.","title":"Default Mode"},{"location":"migration/helm-chart/#prometheus-and-grafana-services","text":"Prior to version v2.1 , when the Metrics chart is deployed, Prometheus and Grafana services are exposed by default through a NodePort . For security reasons, those services are not exposed by default anymore. To expose them you should use the new prometheus.service and grafana.service options, more details in the corresponding values.yaml .","title":"Prometheus and Grafana services"},{"location":"migration/maesh-v1/","text":"Minor Migrations \u00b6 Maesh v1 v1.1 to v1.2 \u00b6 Debug \u00b6 The --debug CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new --logLevel flag with debug as value. SMI Mode \u00b6 The --smi CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new and backward compatible --acl flag.","title":"Maesh v1"},{"location":"migration/maesh-v1/#minor-migrations","text":"Maesh v1","title":"Minor Migrations"},{"location":"migration/maesh-v1/#v11-to-v12","text":"","title":"v1.1 to v1.2"},{"location":"migration/maesh-v1/#debug","text":"The --debug CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new --logLevel flag with debug as value.","title":"Debug"},{"location":"migration/maesh-v1/#smi-mode","text":"The --smi CLI flag is deprecated and will be removed in a future major release. Instead, you should use the new and backward compatible --acl flag.","title":"SMI Mode"}]}